# ArgoCD

While Argo CD can be used to deploy and manage other applications, do not forget that it is also an application by itself. There are many ways to install it on a Kubernetes cluster and in most cases you need to look at your company policy regarding other Kubernetes applications that are critical for your infrastructure.

There are several questions that you need to answer before making a decision about installation:

    Will your Argo CD installation manage only the cluster on which it is installed? Will it manage other clusters? Both?
    Do you want a High Availability (HA) installation or not?
    Do you want to use plain manifests or are you looking for a Helm chart?
    How will you manage Argo CD upgrades? With an external system? Or do you wish for Argo CD to manage itself?


For quick demos and experimentation, you can deploy ArgoCD by directly using the manifests

kubectl create namespace argocd

kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

For a production setup we suggest you use Autopilot, a companion project that not only installs Argo CD, but commits all configuration to git so Argo CD can manage itself using GitOps.

For more traditional installation options, the manifests directory offers different modes of installation with or without High Availability. The installs marked as “namespace” allow you to install Argo CD on a single namespace without cluster-wide privileges. This is best when you want to install Argo CD on one cluster but have it manage other external clusters.

A community helm chart is also available at https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd

Regarding configuration options, Argo CD can be customized a lot after the initial installation, but the absolute essentials are:

    Decide how to expose Argo CD API/UI to your users.
    Decide how users are going to authenticate to Argo CD.


Exposing your Argo CD to users will be a different process depending on your organization, but in most cases, you should make the Argo CD UI available to external traffic via a Kubernetes ingress.

The setup process is not specific to Argo CD, and you should already be familiar with ingresses for other Kubernetes applications. You can follow the official documentation for setting up Argo CD with popular Ingress options.

Once the external URL is ready, you need to decide how users will access the Argo CD UI. There are mainly two approaches:

    Use a small number of local users. Authentication is handled by Argo CD itself. Best for very small companies (e.g. 2-5 people).
    Use an SSO provider. Authentication is handled by the provider. Ideal for companies and large organizations


### Exposing ArgoCD:

By default, Argo CD is only accessible from within the cluster. To expose the UI to users you can utilize any of the standard Kubernetes networking mechanisms such as

    Ingress (recommended for production)
    Load balancer (affects cloud cost)
    NodePort (simple but not very flexible)

For this exercise we will do the simplest way and use a Nodeport service. In a production environment you should use an Ingress.


### Log in the Argo CD UI

Argo CD initially has an admin user with an autogenerated password. You can get the admin password from the default Configmap

kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d > admin-pass.txt

Just to make things simple we have disabled authentication in the ArgoCD UI.

Simply use the "ArgoCD UI" tab to look at the interface Everything is empty right now.


Argo CD CLI
Step 1

### To install the CLI

curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/v2.1.5/argocd-linux-amd64
chmod +x /usr/local/bin/argocd

Step 2

Test that the CLI works by typing

argocd help


## Creating Application

An application can be created in Argo CD from the UI, CLI, or by writing a Kubernetes manifest that can then be passed to kubectl to create resources. 

```bash
argocd app create {APP NAME} \
--project {PROJECT} \
--repo {GIT REPO} \--path {APP FOLDER} \
--dest-namespace {NAMESPACE} \
--dest-server {SERVER URL}
```

- **{APP NAME}** is the name you want to give the application
- **{PROJECT}** is the name of the project created or "default"
- **{GIT REPO}** is the url of the git repository where the gitops config is located
- **{APP FOLDER}** is the path to the configuration for the application in the gitops repo
- **{DEST NAMESPACE}** is the target namespace in the cluster where the application will be deployed
- **{SERVER URL}** is the url of the cluster where the application will be deployed. Use https://kubernetes.default.svc to reference the same cluster where ArgoCD has been deployed.

See the status and configuration of the application

```bash
argocd app list
```

For a more detailed view of the application configuration, run:

```bash
argocd app get {APP NAME}
```

## Syncing an application

Since the application is in **OutOfSync** status once created because it hasn’t been deployed yet, we will then sync the application with a sync command.

```bash
argocd app sync {APP NAME}
```

To confirm it’s running, you can execute a kubectl command.

```bash
kubectl -n {NAMESPACE} get all
```

## Managing Secrets
https://github.com/bitnami-labs/sealed-secrets

Install bitnami secrets controller
```bash
helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets
```

Install kubeseal
```bash
# Fetch the latest sealed-secrets version using GitHub API
KUBESEAL_VERSION=$(curl -s https://api.github.com/repos/bitnami-labs/sealed-secrets/tags | jq -r '.[0].name' | cut -c 2-)

# Check if the version was fetched successfully
if [ -z "$KUBESEAL_VERSION" ]; then
    echo "Failed to fetch the latest KUBESEAL_VERSION"
    exit 1
fi

wget "https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBESEAL_VERSION}/kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz"
tar -xvzf kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz kubeseal
sudo install -m 755 kubeseal /usr/local/bin/kubeseal
```

Encrypt secrets

Example:
```bash
kubeseal < unsealed_secrets/db-creds.yml > sealed_secrets/db-creds-encrypted.yaml -o yaml
```

Push and commit the secret to your secret.yaml and the controller will automatically decrypt the secret when needed.

